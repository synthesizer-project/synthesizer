"""A module containing the definition of an image.

This module contains the definition of an image.

An image can be generated from particle based data with or without smoothing,
and from parametric data with smoothing defined by a morphology derived
density grid.

Example Usage:
        # Particle based case
        img = Image(resolution=0.1 * kpc, fov=1.0 * kpc)
        img.get_img(signal, coordinates * kpc, smoothing_lengths * kpc, kernel)

        # Parametric case
        img = Image(resolution=0.1 * kpc, fov=1.0 * kpc)
        img.get_img(signal, density_grid)
"""
import matplotlib.pyplot as plt
import numpy as np
from scipy.ndimage import zoom
from unyt import unyt_array, unyt_quantity

from synthesizer import exceptions
from synthesizer.units import Quantity


class Image:
    """
    A class for generating images.

    This class is used to generate images from particle based data with or
    without smoothing, and from parametric data with smoothing defined by a
    morphology derived density grid.

    This can be used in isolation to generate singular images or generated by
    an ImageCollection to generate a collection of images in various filters.

    Attributes:
        resolution (unyt_quantity, float):
            The resolution of the image.
        fov (unyt_quantity, float):
            The field of view of the image.
        npix (tuple):
            The number of pixels in the image.
        arr (array_like, float):
            The array containing the image.
        units (unyt.Units):
            The units of the image.
    """

    # Define quantities
    resolution = Quantity()
    fov = Quantity()

    def __init__(self, resolution, fov):
        """
        Create an image with the images metadata.

        Args:
            resolution (unyt_quantity, float):
                The resolution of the image.
            fov (unyt_quantity, float):
                The field of view of the image.
        """
        # Set the quantities
        self.resolution = resolution
        self.fov = fov

        # Calculate the shape of the image
        self.npix = (
            int(self.fov[0] / self.resolution),
            int(self.fov[1] / self.resolution),
        )

        # Attribute to hold the image array itself
        self.arr = None

        # Attributes to hold the image units
        self.units = None

    def resample(self, factor):
        """
        Resample the image by factor.

        Args:
            factor (float)
                The factor by which to resample the image, >1 increases
                resolution, <1 decreases resolution.
        """
        # Perform the conversion on the basic image properties
        self.resolution /= factor
        self._compute_npix()

        # Resample the image.
        # NOTE: skimage.transform.pyramid_gaussian is more efficient but adds
        #       another dependency.
        if self.img is not None:
            self.img = zoom(self.img, factor)
            new_shape = self.img.shape
        else:
            raise exceptions.MissingImage(
                "The image array hasn't been generated yet. Please run "
                "get_img_hist() or get_img_smoothed() before resampling."
            )

        # Handle the edge case where the conversion between resolutions has
        # messed with Scene properties.
        if self.npix != new_shape[0]:
            self.npix = new_shape
            self._compute_fov()

    def __add__(self, other_img):
        """
        Add 2 Images together.

        Args:
        """
        pass

    def __mul__(self, mult):
        """
        Multiply the image by a multiplier.

        Args:
            mult (int/float/array-like)
                The number to multiply the image array by.

        Returns:
            Image
                The new image containing the multipled array.
        """
        # Create the new image
        new_img = Image(self.resolution, self.fov)

        # Associate the image array and units
        new_img.arr = self.arr
        new_img.units = self.units

        # Multiply the image array
        new_img.arr *= mult
        return new_img

    def get_img_hist(
        self,
        signal,
        coordinates=None,
    ):
        """
        Calculate an image with no smoothing.

        This is only applicable to particle based images and is just a
        wrapper for numpy.histogram2d.

        Args:
            signal (array_like, float):
                The signal to be sorted into the image.
            coordinates (unyt_array, float):
                The coordinates of the particles.

        Returns:
            img (array_like, float)
                A 2D array containing the pixel values sorted into the image.
                (npix, npix)
        """
        # Strip off and store the units on the signal if they are present
        if isinstance(signal, (unyt_quantity, unyt_array)):
            self.units = signal.units
            signal = signal.value

        # Convert coordinates and smoothing lengths to the correct units and
        # strip them off
        coordinates = coordinates.to(self.resolution.units).value

        self.arr = np.histogram2d(
            coordinates[:, 0],
            coordinates[:, 1],
            bins=self.npix,
            weights=signal,
        )[0]

        return self.arr * self.units if self.units is not None else self.arr

    def get_img_smoothed(
        self,
        signal,
        coordinates=None,
        smoothing_lengths=None,
        kernel=None,
        density_grid=None,
    ):
        """
        Calculate a smoothed image.

        In the particle case this smooths each particle's signal over the SPH
        kernel defined by their smoothing length. This uses C extensions to
        calculate the image for each particle efficiently.

        In the parametric case the signal is smoothed over a density grid. This
        density grid is an array defining the weight in each pixel.

        Args:
            signal (array_like, float):
                The signal to be sorted into the image.
            coordinates (unyt_array, float):
                The coordinates of the particles. (particle case only)
            smoothing_lengths (unyt_array, float):
                The smoothing lengths of the particles. (particle case only)
            kernel (str):
                The kernel to use for smoothing. (particle case only)
            density_grid (array_like, float):
                The density grid to smooth over. (parametric case only)

        Returns:
            img : array_like (float)
                A 2D array containing particles sorted into an image.
                (npix[0], npix[1])

        Raises:
            InconsistentArguments
                If conflicting particle and parametric arguments are passed
                or any arguments are missing an error is raised.
        """
        # Strip off and store the units on the signal if they are present
        if isinstance(signal, (unyt_quantity, unyt_array)):
            self.units = signal.units
            signal = signal.value

        # Ensure we have the right arguments
        if density_grid is not None and (
            coordinates is not None
            or smoothing_lengths is not None
            or kernel is not None
        ):
            raise exceptions.InconsistentArguments(
                "Parametric smoothed images only require a density grid. You "
                "Shouldn't have particle based quantities in conjunction with "
                "parametric properties, what are you doing?"
            )
        if density_grid is None and (
            coordinates is None or smoothing_lengths is None or kernel is None
        ):
            raise exceptions.InconsistentArguments(
                "Particle based smoothed images require the coordinates, "
                "smoothing_lengths, and kernel arguments to be passed."
            )

        # Handle the parametric case
        if density_grid is not None:
            # Multiply the density grid by the sed to get the IFU
            self.img = density_grid[:, :] * signal

            return (
                self.arr * self.units if self.units is not None else self.arr
            )

        from .extensions.image import make_img

        # Convert coordinates and smoothing lengths to the correct units and
        # strip them off
        coordinates = coordinates.to(self.resolution.units).value
        smoothing_lengths = smoothing_lengths.to(self.resolution.units).value

        # Prepare the inputs, we need to make sure we are passing C contiguous
        # arrays.
        signal = np.ascontiguousarray(signal, dtype=np.float64)
        smls = np.ascontiguousarray(smoothing_lengths, dtype=np.float64)
        xs = np.ascontiguousarray(coordinates[:, 0], dtype=np.float64)
        ys = np.ascontiguousarray(coordinates[:, 1], dtype=np.float64)

        self.arr = make_img(
            signal,
            smls,
            xs,
            ys,
            self.kernel,
            self._resolution,
            self.npix[0],
            self.coordinates.shape[0],
            self.kernel_threshold,
            self.kernel_dim,
        )

        return self.arr * self.units if self.units is not None else self.arr

    def apply_psf(self, psf):
        pass

    def apply_noise(self, noise):
        pass

    def plot_map(
        self,
        show=False,
        vmin=None,
        vmax=None,
        extent=None,
        cmap="Greys_r",
        cbar_label=None,
        norm=None,
        tick_formatter=None,
    ):
        """
        Plot a map. Unlike an image we want a colorbar and know ahead of time
        there is only 1 image in the Image and only a "standard" image.

        Args:
            show (bool)
                Whether to show the plot or not (Default False).
            extent (array_like)
                The extent of the x and y axes.
            cmap (str)
                The name of the matplotlib colormap for image plotting. Can be
                any valid string that can be passed to the cmap argument of
                imshow. Defaults to "Greys_r".
            cbar_label (str)
                The label for the colorbar.
            norm (function)
                A normalisation function. This can be custom made or one of
                matplotlib's normalisation functions. It must take an array and
                return the same array after normalisation.
            tick_formatter (matplotlib.ticker.FuncFormatter)
                An instance of the tick formatter for formatting the colorbar
                ticks.

        Returns:
            matplotlib.pyplot.figure
                The figure object containing the plot
            matplotlib.pyplot.figure.axis
                The axis object containing the image.

        Raises:
            MissingImage
                If there is no image then there's nothing to plot and an error
                is thrown.
        """

        # Ensure an img exists
        if self.img is None:
            raise exceptions.MissingImage("There is no image to plot!")

        # Get the image
        img = self.img

        # Set up the figure
        fig = plt.figure(figsize=(3.5, 3.5))

        # Create the axis
        ax = fig.add_subplot(111)

        # Plot the image and remove the surrounding axis
        im = ax.imshow(
            img,
            extent=extent,
            origin="lower",
            interpolation="nearest",
            cmap=cmap,
            norm=norm,
        )

        # Make the colorbar with the format if provided
        cbar = fig.colorbar(im, format=tick_formatter)
        if cbar_label is not None:
            cbar.set_label(cbar_label)

        if show:
            plt.show()

        return fig, ax
